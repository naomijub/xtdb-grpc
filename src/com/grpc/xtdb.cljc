;;;----------------------------------------------------------------------------------
;;; Generated by protoc-gen-clojure.  DO NOT EDIT
;;;
;;; Message Implementation of package com.grpc.xtdb
;;;----------------------------------------------------------------------------------
(ns com.grpc.xtdb
  (:require [protojure.protobuf.protocol :as pb]
            [protojure.protobuf.serdes.core :as serdes.core]
            [protojure.protobuf.serdes.complex :as serdes.complex]
            [protojure.protobuf.serdes.utils :refer [tag-map]]
            [protojure.protobuf.serdes.stream :as serdes.stream]
            [com.google.protobuf :as com.google.protobuf]
            [com.grpc.xtdb :as com.grpc.xtdb]
            [clojure.set :as set]
            [clojure.spec.alpha :as s]))

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Forward declarations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

(declare cis->Empty)
(declare ecis->Empty)
(declare new-Empty)
(declare cis->StatusResponse)
(declare ecis->StatusResponse)
(declare new-StatusResponse)
(declare cis->Evict)
(declare ecis->Evict)
(declare new-Evict)
(declare cis->EntityHistoryResponse)
(declare ecis->EntityHistoryResponse)
(declare new-EntityHistoryResponse)
(declare cis->Put)
(declare ecis->Put)
(declare new-Put)
(declare cis->EntityRequest)
(declare ecis->EntityRequest)
(declare new-EntityRequest)
(declare cis->None)
(declare ecis->None)
(declare new-None)
(declare cis->Delete)
(declare ecis->Delete)
(declare new-Delete)
(declare cis->SubmitRequest)
(declare ecis->SubmitRequest)
(declare new-SubmitRequest)
(declare cis->EntityHistoryResponseUnit)
(declare ecis->EntityHistoryResponseUnit)
(declare new-EntityHistoryResponseUnit)
(declare cis->OptionalString)
(declare ecis->OptionalString)
(declare new-OptionalString)
(declare cis->PutFunction)
(declare ecis->PutFunction)
(declare new-PutFunction)
(declare cis->SubmitResponse)
(declare ecis->SubmitResponse)
(declare new-SubmitResponse)
(declare cis->EntityResponse)
(declare ecis->EntityResponse)
(declare new-EntityResponse)
(declare cis->EntityHistoryRequest)
(declare ecis->EntityHistoryRequest)
(declare new-EntityHistoryRequest)
(declare cis->OptionalBool)
(declare ecis->OptionalBool)
(declare new-OptionalBool)
(declare cis->EntityTxRequest)
(declare ecis->EntityTxRequest)
(declare new-EntityTxRequest)
(declare cis->EntityTxResponse)
(declare ecis->EntityTxResponse)
(declare new-EntityTxResponse)
(declare cis->Function)
(declare ecis->Function)
(declare new-Function)
(declare cis->Transaction)
(declare ecis->Transaction)
(declare new-Transaction)
(declare cis->OptionalInt64)
(declare ecis->OptionalInt64)
(declare new-OptionalInt64)
(declare cis->Match)
(declare ecis->Match)
(declare new-Match)

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Enumerations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

;-----------------------------------------------------------------------------
; SortOrder
;-----------------------------------------------------------------------------
(def SortOrder-default :asc)

(def SortOrder-val2label {0 :asc
                          1 :desc})

(def SortOrder-label2val (set/map-invert SortOrder-val2label))

(defn cis->SortOrder [is]
  (let [val (serdes.core/cis->Enum is)]
    (get SortOrder-val2label val val)))

(defn- get-SortOrder [value]
  {:pre [(or (int? value) (contains? SortOrder-label2val value))]}
  (get SortOrder-label2val value value))

(defn write-SortOrder
  ([tag value os] (write-SortOrder tag {:optimize false} value os))
  ([tag options value os]
   (serdes.core/write-Enum tag options (get-SortOrder value) os)))

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; OptionalString-option's oneof Implementations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

(defn convert-OptionalString-option [origkeyval]
  (cond
    (get-in origkeyval [:option :some]) origkeyval
    (get-in origkeyval [:option :none]) (update-in origkeyval [:option :none] new-None)
    :default origkeyval))

(defn write-OptionalString-option [option os]
  (let [field (first option)
        k (when-not (nil? field) (key field))
        v (when-not (nil? field) (val field))]
    (case k
      :some (serdes.core/write-String 1  {:optimize false} v os)
      :none (serdes.core/write-embedded 2 v os)
      nil)))

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; OptionalBool-option's oneof Implementations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

(defn convert-OptionalBool-option [origkeyval]
  (cond
    (get-in origkeyval [:option :some]) origkeyval
    (get-in origkeyval [:option :none]) (update-in origkeyval [:option :none] new-None)
    :default origkeyval))

(defn write-OptionalBool-option [option os]
  (let [field (first option)
        k (when-not (nil? field) (key field))
        v (when-not (nil? field) (val field))]
    (case k
      :some (serdes.core/write-Bool 1  {:optimize false} v os)
      :none (serdes.core/write-embedded 2 v os)
      nil)))

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Transaction-transaction-type's oneof Implementations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

(defn convert-Transaction-transaction-type [origkeyval]
  (cond
    (get-in origkeyval [:transaction-type :put]) (update-in origkeyval [:transaction-type :put] new-Put)
    (get-in origkeyval [:transaction-type :delete]) (update-in origkeyval [:transaction-type :delete] new-Delete)
    (get-in origkeyval [:transaction-type :match]) (update-in origkeyval [:transaction-type :match] new-Match)
    (get-in origkeyval [:transaction-type :evict]) (update-in origkeyval [:transaction-type :evict] new-Evict)
    (get-in origkeyval [:transaction-type :function]) (update-in origkeyval [:transaction-type :function] new-Function)
    (get-in origkeyval [:transaction-type :put-function]) (update-in origkeyval [:transaction-type :put-function] new-PutFunction)
    :default origkeyval))

(defn write-Transaction-transaction-type [transaction-type os]
  (let [field (first transaction-type)
        k (when-not (nil? field) (key field))
        v (when-not (nil? field) (val field))]
    (case k
      :put (serdes.core/write-embedded 1 v os)
      :delete (serdes.core/write-embedded 2 v os)
      :match (serdes.core/write-embedded 3 v os)
      :evict (serdes.core/write-embedded 4 v os)
      :function (serdes.core/write-embedded 5 v os)
      :put-function (serdes.core/write-embedded 6 v os)
      nil)))

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; OptionalInt64-option's oneof Implementations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

(defn convert-OptionalInt64-option [origkeyval]
  (cond
    (get-in origkeyval [:option :some]) origkeyval
    (get-in origkeyval [:option :none]) (update-in origkeyval [:option :none] new-None)
    :default origkeyval))

(defn write-OptionalInt64-option [option os]
  (let [field (first option)
        k (when-not (nil? field) (key field))
        v (when-not (nil? field) (val field))]
    (case k
      :some (serdes.core/write-Int64 1  {:optimize false} v os)
      :none (serdes.core/write-embedded 2 v os)
      nil)))

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Message Implementations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

;-----------------------------------------------------------------------------
; Empty
;-----------------------------------------------------------------------------
(defrecord Empty-record []
  pb/Writer
  (serialize [this os])
  pb/TypeReflection
  (gettype [this]
    "com.grpc.xtdb.Empty"))

(s/def ::Empty-spec (s/keys :opt-un []))
(def Empty-defaults {})

(defn cis->Empty
  "CodedInputStream to Empty"
  [is]
  (->> (tag-map Empty-defaults
                (fn [tag index]
                  (case index
                    [index (serdes.core/cis->undefined tag is)]))
                is)
       (map->Empty-record)))

(defn ecis->Empty
  "Embedded CodedInputStream to Empty"
  [is]
  (serdes.core/cis->embedded cis->Empty is))

(defn new-Empty
  "Creates a new instance from a map, similar to map->Empty except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Empty-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Empty-spec init))))]}
  (-> (merge Empty-defaults init)
      (map->Empty-record)))

(defn pb->Empty
  "Protobuf to Empty"
  [input]
  (cis->Empty (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Empty-meta {:type "com.grpc.xtdb.Empty" :decoder pb->Empty})

;-----------------------------------------------------------------------------
; StatusResponse
;-----------------------------------------------------------------------------
(defrecord StatusResponse-record [version index-version kv-store estimate-num-keys size revision consumer-state]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:version this) os)
    (serdes.core/write-Int32 2  {:optimize true} (:index-version this) os)
    (serdes.core/write-String 3  {:optimize true} (:kv-store this) os)
    (serdes.core/write-Int32 4  {:optimize true} (:estimate-num-keys this) os)
    (serdes.core/write-Int64 5  {:optimize true} (:size this) os)
    (serdes.core/write-embedded 6 (:revision this) os)
    (serdes.core/write-embedded 7 (:consumer-state this) os))
  pb/TypeReflection
  (gettype [this]
    "com.grpc.xtdb.StatusResponse"))

(s/def :com.grpc.xtdb.StatusResponse/version string?)
(s/def :com.grpc.xtdb.StatusResponse/index-version int?)
(s/def :com.grpc.xtdb.StatusResponse/kv-store string?)
(s/def :com.grpc.xtdb.StatusResponse/estimate-num-keys int?)
(s/def :com.grpc.xtdb.StatusResponse/size int?)

(s/def ::StatusResponse-spec (s/keys :opt-un [:com.grpc.xtdb.StatusResponse/version :com.grpc.xtdb.StatusResponse/index-version :com.grpc.xtdb.StatusResponse/kv-store :com.grpc.xtdb.StatusResponse/estimate-num-keys :com.grpc.xtdb.StatusResponse/size]))
(def StatusResponse-defaults {:version "" :index-version 0 :kv-store "" :estimate-num-keys 0 :size 0})

(defn cis->StatusResponse
  "CodedInputStream to StatusResponse"
  [is]
  (->> (tag-map StatusResponse-defaults
                (fn [tag index]
                  (case index
                    1 [:version (serdes.core/cis->String is)]
                    2 [:index-version (serdes.core/cis->Int32 is)]
                    3 [:kv-store (serdes.core/cis->String is)]
                    4 [:estimate-num-keys (serdes.core/cis->Int32 is)]
                    5 [:size (serdes.core/cis->Int64 is)]
                    6 [:revision (ecis->OptionalString is)]
                    7 [:consumer-state (ecis->OptionalString is)]

                    [index (serdes.core/cis->undefined tag is)]))
                is)
       (map->StatusResponse-record)))

(defn ecis->StatusResponse
  "Embedded CodedInputStream to StatusResponse"
  [is]
  (serdes.core/cis->embedded cis->StatusResponse is))

(defn new-StatusResponse
  "Creates a new instance from a map, similar to map->StatusResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::StatusResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::StatusResponse-spec init))))]}
  (-> (merge StatusResponse-defaults init)
      (cond-> (some? (get init :revision)) (update :revision new-OptionalString))
      (cond-> (some? (get init :consumer-state)) (update :consumer-state new-OptionalString))
      (map->StatusResponse-record)))

(defn pb->StatusResponse
  "Protobuf to StatusResponse"
  [input]
  (cis->StatusResponse (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record StatusResponse-meta {:type "com.grpc.xtdb.StatusResponse" :decoder pb->StatusResponse})

;-----------------------------------------------------------------------------
; Evict
;-----------------------------------------------------------------------------
(defrecord Evict-record [document-id]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:document-id this) os))
  pb/TypeReflection
  (gettype [this]
    "com.grpc.xtdb.Evict"))

(s/def :com.grpc.xtdb.Evict/document-id string?)
(s/def ::Evict-spec (s/keys :opt-un [:com.grpc.xtdb.Evict/document-id]))
(def Evict-defaults {:document-id ""})

(defn cis->Evict
  "CodedInputStream to Evict"
  [is]
  (->> (tag-map Evict-defaults
                (fn [tag index]
                  (case index
                    1 [:document-id (serdes.core/cis->String is)]

                    [index (serdes.core/cis->undefined tag is)]))
                is)
       (map->Evict-record)))

(defn ecis->Evict
  "Embedded CodedInputStream to Evict"
  [is]
  (serdes.core/cis->embedded cis->Evict is))

(defn new-Evict
  "Creates a new instance from a map, similar to map->Evict except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Evict-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Evict-spec init))))]}
  (-> (merge Evict-defaults init)
      (map->Evict-record)))

(defn pb->Evict
  "Protobuf to Evict"
  [input]
  (cis->Evict (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Evict-meta {:type "com.grpc.xtdb.Evict" :decoder pb->Evict})

;-----------------------------------------------------------------------------
; EntityHistoryResponse
;-----------------------------------------------------------------------------
(defrecord EntityHistoryResponse-record [list]
  pb/Writer
  (serialize [this os]
    (serdes.complex/write-repeated serdes.core/write-embedded 1 (:list this) os))
  pb/TypeReflection
  (gettype [this]
    "com.grpc.xtdb.EntityHistoryResponse"))

(s/def ::EntityHistoryResponse-spec (s/keys :opt-un []))
(def EntityHistoryResponse-defaults {:list []})

(defn cis->EntityHistoryResponse
  "CodedInputStream to EntityHistoryResponse"
  [is]
  (->> (tag-map EntityHistoryResponse-defaults
                (fn [tag index]
                  (case index
                    1 [:list (serdes.complex/cis->repeated ecis->EntityHistoryResponseUnit is)]

                    [index (serdes.core/cis->undefined tag is)]))
                is)
       (map->EntityHistoryResponse-record)))

(defn ecis->EntityHistoryResponse
  "Embedded CodedInputStream to EntityHistoryResponse"
  [is]
  (serdes.core/cis->embedded cis->EntityHistoryResponse is))

(defn new-EntityHistoryResponse
  "Creates a new instance from a map, similar to map->EntityHistoryResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::EntityHistoryResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::EntityHistoryResponse-spec init))))]}
  (-> (merge EntityHistoryResponse-defaults init)
      (cond-> (some? (get init :list)) (update :list #(map new-EntityHistoryResponseUnit %)))
      (map->EntityHistoryResponse-record)))

(defn pb->EntityHistoryResponse
  "Protobuf to EntityHistoryResponse"
  [input]
  (cis->EntityHistoryResponse (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record EntityHistoryResponse-meta {:type "com.grpc.xtdb.EntityHistoryResponse" :decoder pb->EntityHistoryResponse})

;-----------------------------------------------------------------------------
; Put
;-----------------------------------------------------------------------------
(defrecord Put-record [document valid-time end-valid-time]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-embedded 1 (:document this) os)
    (serdes.core/write-String 2  {:optimize true} (:valid-time this) os)
    (serdes.core/write-String 3  {:optimize true} (:end-valid-time this) os))
  pb/TypeReflection
  (gettype [this]
    "com.grpc.xtdb.Put"))

(s/def :com.grpc.xtdb.Put/valid-time string?)
(s/def :com.grpc.xtdb.Put/end-valid-time string?)
(s/def ::Put-spec (s/keys :opt-un [:com.grpc.xtdb.Put/valid-time :com.grpc.xtdb.Put/end-valid-time]))
(def Put-defaults {:valid-time "" :end-valid-time ""})

(defn cis->Put
  "CodedInputStream to Put"
  [is]
  (->> (tag-map Put-defaults
                (fn [tag index]
                  (case index
                    1 [:document (com.google.protobuf/ecis->Value is)]
                    2 [:valid-time (serdes.core/cis->String is)]
                    3 [:end-valid-time (serdes.core/cis->String is)]

                    [index (serdes.core/cis->undefined tag is)]))
                is)
       (map->Put-record)))

(defn ecis->Put
  "Embedded CodedInputStream to Put"
  [is]
  (serdes.core/cis->embedded cis->Put is))

(defn new-Put
  "Creates a new instance from a map, similar to map->Put except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Put-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Put-spec init))))]}
  (-> (merge Put-defaults init)
      (cond-> (some? (get init :document)) (update :document com.google.protobuf/new-Value))
      (map->Put-record)))

(defn pb->Put
  "Protobuf to Put"
  [input]
  (cis->Put (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Put-meta {:type "com.grpc.xtdb.Put" :decoder pb->Put})

;-----------------------------------------------------------------------------
; EntityRequest
;-----------------------------------------------------------------------------
(defrecord EntityRequest-record [eid]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:eid this) os))
  pb/TypeReflection
  (gettype [this]
    "com.grpc.xtdb.EntityRequest"))

(s/def :com.grpc.xtdb.EntityRequest/eid string?)
(s/def ::EntityRequest-spec (s/keys :opt-un [:com.grpc.xtdb.EntityRequest/eid]))
(def EntityRequest-defaults {:eid ""})

(defn cis->EntityRequest
  "CodedInputStream to EntityRequest"
  [is]
  (->> (tag-map EntityRequest-defaults
                (fn [tag index]
                  (case index
                    1 [:eid (serdes.core/cis->String is)]

                    [index (serdes.core/cis->undefined tag is)]))
                is)
       (map->EntityRequest-record)))

(defn ecis->EntityRequest
  "Embedded CodedInputStream to EntityRequest"
  [is]
  (serdes.core/cis->embedded cis->EntityRequest is))

(defn new-EntityRequest
  "Creates a new instance from a map, similar to map->EntityRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::EntityRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::EntityRequest-spec init))))]}
  (-> (merge EntityRequest-defaults init)
      (map->EntityRequest-record)))

(defn pb->EntityRequest
  "Protobuf to EntityRequest"
  [input]
  (cis->EntityRequest (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record EntityRequest-meta {:type "com.grpc.xtdb.EntityRequest" :decoder pb->EntityRequest})

;-----------------------------------------------------------------------------
; None
;-----------------------------------------------------------------------------
(defrecord None-record []
  pb/Writer
  (serialize [this os])
  pb/TypeReflection
  (gettype [this]
    "com.grpc.xtdb.None"))

(s/def ::None-spec (s/keys :opt-un []))
(def None-defaults {})

(defn cis->None
  "CodedInputStream to None"
  [is]
  (->> (tag-map None-defaults
                (fn [tag index]
                  (case index
                    [index (serdes.core/cis->undefined tag is)]))
                is)
       (map->None-record)))

(defn ecis->None
  "Embedded CodedInputStream to None"
  [is]
  (serdes.core/cis->embedded cis->None is))

(defn new-None
  "Creates a new instance from a map, similar to map->None except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::None-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::None-spec init))))]}
  (-> (merge None-defaults init)
      (map->None-record)))

(defn pb->None
  "Protobuf to None"
  [input]
  (cis->None (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record None-meta {:type "com.grpc.xtdb.None" :decoder pb->None})

;-----------------------------------------------------------------------------
; Delete
;-----------------------------------------------------------------------------
(defrecord Delete-record [document-id valid-time end-valid-time]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:document-id this) os)
    (serdes.core/write-String 2  {:optimize true} (:valid-time this) os)
    (serdes.core/write-String 3  {:optimize true} (:end-valid-time this) os))
  pb/TypeReflection
  (gettype [this]
    "com.grpc.xtdb.Delete"))

(s/def :com.grpc.xtdb.Delete/document-id string?)
(s/def :com.grpc.xtdb.Delete/valid-time string?)
(s/def :com.grpc.xtdb.Delete/end-valid-time string?)
(s/def ::Delete-spec (s/keys :opt-un [:com.grpc.xtdb.Delete/document-id :com.grpc.xtdb.Delete/valid-time :com.grpc.xtdb.Delete/end-valid-time]))
(def Delete-defaults {:document-id "" :valid-time "" :end-valid-time ""})

(defn cis->Delete
  "CodedInputStream to Delete"
  [is]
  (->> (tag-map Delete-defaults
                (fn [tag index]
                  (case index
                    1 [:document-id (serdes.core/cis->String is)]
                    2 [:valid-time (serdes.core/cis->String is)]
                    3 [:end-valid-time (serdes.core/cis->String is)]

                    [index (serdes.core/cis->undefined tag is)]))
                is)
       (map->Delete-record)))

(defn ecis->Delete
  "Embedded CodedInputStream to Delete"
  [is]
  (serdes.core/cis->embedded cis->Delete is))

(defn new-Delete
  "Creates a new instance from a map, similar to map->Delete except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Delete-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Delete-spec init))))]}
  (-> (merge Delete-defaults init)
      (map->Delete-record)))

(defn pb->Delete
  "Protobuf to Delete"
  [input]
  (cis->Delete (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Delete-meta {:type "com.grpc.xtdb.Delete" :decoder pb->Delete})

;-----------------------------------------------------------------------------
; SubmitRequest
;-----------------------------------------------------------------------------
(defrecord SubmitRequest-record [tx-ops]
  pb/Writer
  (serialize [this os]
    (serdes.complex/write-repeated serdes.core/write-embedded 1 (:tx-ops this) os))
  pb/TypeReflection
  (gettype [this]
    "com.grpc.xtdb.SubmitRequest"))

(s/def ::SubmitRequest-spec (s/keys :opt-un []))
(def SubmitRequest-defaults {:tx-ops []})

(defn cis->SubmitRequest
  "CodedInputStream to SubmitRequest"
  [is]
  (->> (tag-map SubmitRequest-defaults
                (fn [tag index]
                  (case index
                    1 [:tx-ops (serdes.complex/cis->repeated ecis->Transaction is)]

                    [index (serdes.core/cis->undefined tag is)]))
                is)
       (map->SubmitRequest-record)))

(defn ecis->SubmitRequest
  "Embedded CodedInputStream to SubmitRequest"
  [is]
  (serdes.core/cis->embedded cis->SubmitRequest is))

(defn new-SubmitRequest
  "Creates a new instance from a map, similar to map->SubmitRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::SubmitRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::SubmitRequest-spec init))))]}
  (-> (merge SubmitRequest-defaults init)
      (cond-> (some? (get init :tx-ops)) (update :tx-ops #(map new-Transaction %)))
      (map->SubmitRequest-record)))

(defn pb->SubmitRequest
  "Protobuf to SubmitRequest"
  [input]
  (cis->SubmitRequest (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record SubmitRequest-meta {:type "com.grpc.xtdb.SubmitRequest" :decoder pb->SubmitRequest})

;-----------------------------------------------------------------------------
; EntityHistoryResponseUnit
;-----------------------------------------------------------------------------
(defrecord EntityHistoryResponseUnit-record [content-hash valid-time tx-time tx-id doc]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:content-hash this) os)
    (serdes.core/write-String 2  {:optimize true} (:valid-time this) os)
    (serdes.core/write-String 3  {:optimize true} (:tx-time this) os)
    (serdes.core/write-Int64 4  {:optimize true} (:tx-id this) os)
    (serdes.core/write-String 5  {:optimize true} (:doc this) os))
  pb/TypeReflection
  (gettype [this]
    "com.grpc.xtdb.EntityHistoryResponseUnit"))

(s/def :com.grpc.xtdb.EntityHistoryResponseUnit/content-hash string?)
(s/def :com.grpc.xtdb.EntityHistoryResponseUnit/valid-time string?)
(s/def :com.grpc.xtdb.EntityHistoryResponseUnit/tx-time string?)
(s/def :com.grpc.xtdb.EntityHistoryResponseUnit/tx-id int?)
(s/def :com.grpc.xtdb.EntityHistoryResponseUnit/doc string?)
(s/def ::EntityHistoryResponseUnit-spec (s/keys :opt-un [:com.grpc.xtdb.EntityHistoryResponseUnit/content-hash :com.grpc.xtdb.EntityHistoryResponseUnit/valid-time :com.grpc.xtdb.EntityHistoryResponseUnit/tx-time :com.grpc.xtdb.EntityHistoryResponseUnit/tx-id :com.grpc.xtdb.EntityHistoryResponseUnit/doc]))
(def EntityHistoryResponseUnit-defaults {:content-hash "" :valid-time "" :tx-time "" :tx-id 0 :doc ""})

(defn cis->EntityHistoryResponseUnit
  "CodedInputStream to EntityHistoryResponseUnit"
  [is]
  (->> (tag-map EntityHistoryResponseUnit-defaults
                (fn [tag index]
                  (case index
                    1 [:content-hash (serdes.core/cis->String is)]
                    2 [:valid-time (serdes.core/cis->String is)]
                    3 [:tx-time (serdes.core/cis->String is)]
                    4 [:tx-id (serdes.core/cis->Int64 is)]
                    5 [:doc (serdes.core/cis->String is)]

                    [index (serdes.core/cis->undefined tag is)]))
                is)
       (map->EntityHistoryResponseUnit-record)))

(defn ecis->EntityHistoryResponseUnit
  "Embedded CodedInputStream to EntityHistoryResponseUnit"
  [is]
  (serdes.core/cis->embedded cis->EntityHistoryResponseUnit is))

(defn new-EntityHistoryResponseUnit
  "Creates a new instance from a map, similar to map->EntityHistoryResponseUnit except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::EntityHistoryResponseUnit-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::EntityHistoryResponseUnit-spec init))))]}
  (-> (merge EntityHistoryResponseUnit-defaults init)
      (map->EntityHistoryResponseUnit-record)))

(defn pb->EntityHistoryResponseUnit
  "Protobuf to EntityHistoryResponseUnit"
  [input]
  (cis->EntityHistoryResponseUnit (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record EntityHistoryResponseUnit-meta {:type "com.grpc.xtdb.EntityHistoryResponseUnit" :decoder pb->EntityHistoryResponseUnit})

;-----------------------------------------------------------------------------
; OptionalString
;-----------------------------------------------------------------------------
(defrecord OptionalString-record [option]
  pb/Writer
  (serialize [this os]
    (write-OptionalString-option  (:option this) os))
  pb/TypeReflection
  (gettype [this]
    "com.grpc.xtdb.OptionalString"))

(s/def ::OptionalString-spec (s/keys :opt-un []))
(def OptionalString-defaults {})

(defn cis->OptionalString
  "CodedInputStream to OptionalString"
  [is]
  (->> (tag-map OptionalString-defaults
                (fn [tag index]
                  (case index
                    1 [:option {:some (serdes.core/cis->String is)}]
                    2 [:option {:none (ecis->None is)}]

                    [index (serdes.core/cis->undefined tag is)]))
                is)
       (map->OptionalString-record)))

(defn ecis->OptionalString
  "Embedded CodedInputStream to OptionalString"
  [is]
  (serdes.core/cis->embedded cis->OptionalString is))

(defn new-OptionalString
  "Creates a new instance from a map, similar to map->OptionalString except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::OptionalString-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::OptionalString-spec init))))]}
  (-> (merge OptionalString-defaults init)
      (convert-OptionalString-option)
      (map->OptionalString-record)))

(defn pb->OptionalString
  "Protobuf to OptionalString"
  [input]
  (cis->OptionalString (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record OptionalString-meta {:type "com.grpc.xtdb.OptionalString" :decoder pb->OptionalString})

;-----------------------------------------------------------------------------
; PutFunction
;-----------------------------------------------------------------------------
(defrecord PutFunction-record [xt-id xt-fn]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:xt-id this) os)
    (serdes.core/write-String 2  {:optimize true} (:xt-fn this) os))
  pb/TypeReflection
  (gettype [this]
    "com.grpc.xtdb.PutFunction"))

(s/def :com.grpc.xtdb.PutFunction/xt-id string?)
(s/def :com.grpc.xtdb.PutFunction/xt-fn string?)
(s/def ::PutFunction-spec (s/keys :opt-un [:com.grpc.xtdb.PutFunction/xt-id :com.grpc.xtdb.PutFunction/xt-fn]))
(def PutFunction-defaults {:xt-id "" :xt-fn ""})

(defn cis->PutFunction
  "CodedInputStream to PutFunction"
  [is]
  (->> (tag-map PutFunction-defaults
                (fn [tag index]
                  (case index
                    1 [:xt-id (serdes.core/cis->String is)]
                    2 [:xt-fn (serdes.core/cis->String is)]

                    [index (serdes.core/cis->undefined tag is)]))
                is)
       (map->PutFunction-record)))

(defn ecis->PutFunction
  "Embedded CodedInputStream to PutFunction"
  [is]
  (serdes.core/cis->embedded cis->PutFunction is))

(defn new-PutFunction
  "Creates a new instance from a map, similar to map->PutFunction except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::PutFunction-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::PutFunction-spec init))))]}
  (-> (merge PutFunction-defaults init)
      (map->PutFunction-record)))

(defn pb->PutFunction
  "Protobuf to PutFunction"
  [input]
  (cis->PutFunction (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record PutFunction-meta {:type "com.grpc.xtdb.PutFunction" :decoder pb->PutFunction})

;-----------------------------------------------------------------------------
; SubmitResponse
;-----------------------------------------------------------------------------
(defrecord SubmitResponse-record [tx-time tx-id]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:tx-time this) os)
    (serdes.core/write-Int64 2  {:optimize true} (:tx-id this) os))
  pb/TypeReflection
  (gettype [this]
    "com.grpc.xtdb.SubmitResponse"))

(s/def :com.grpc.xtdb.SubmitResponse/tx-time string?)
(s/def :com.grpc.xtdb.SubmitResponse/tx-id int?)
(s/def ::SubmitResponse-spec (s/keys :opt-un [:com.grpc.xtdb.SubmitResponse/tx-time :com.grpc.xtdb.SubmitResponse/tx-id]))
(def SubmitResponse-defaults {:tx-time "" :tx-id 0})

(defn cis->SubmitResponse
  "CodedInputStream to SubmitResponse"
  [is]
  (->> (tag-map SubmitResponse-defaults
                (fn [tag index]
                  (case index
                    1 [:tx-time (serdes.core/cis->String is)]
                    2 [:tx-id (serdes.core/cis->Int64 is)]

                    [index (serdes.core/cis->undefined tag is)]))
                is)
       (map->SubmitResponse-record)))

(defn ecis->SubmitResponse
  "Embedded CodedInputStream to SubmitResponse"
  [is]
  (serdes.core/cis->embedded cis->SubmitResponse is))

(defn new-SubmitResponse
  "Creates a new instance from a map, similar to map->SubmitResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::SubmitResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::SubmitResponse-spec init))))]}
  (-> (merge SubmitResponse-defaults init)
      (map->SubmitResponse-record)))

(defn pb->SubmitResponse
  "Protobuf to SubmitResponse"
  [input]
  (cis->SubmitResponse (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record SubmitResponse-meta {:type "com.grpc.xtdb.SubmitResponse" :decoder pb->SubmitResponse})

;-----------------------------------------------------------------------------
; EntityResponse
;-----------------------------------------------------------------------------
(defrecord EntityResponse-record [edn]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:edn this) os))
  pb/TypeReflection
  (gettype [this]
    "com.grpc.xtdb.EntityResponse"))

(s/def :com.grpc.xtdb.EntityResponse/edn string?)
(s/def ::EntityResponse-spec (s/keys :opt-un [:com.grpc.xtdb.EntityResponse/edn]))
(def EntityResponse-defaults {:edn ""})

(defn cis->EntityResponse
  "CodedInputStream to EntityResponse"
  [is]
  (->> (tag-map EntityResponse-defaults
                (fn [tag index]
                  (case index
                    1 [:edn (serdes.core/cis->String is)]

                    [index (serdes.core/cis->undefined tag is)]))
                is)
       (map->EntityResponse-record)))

(defn ecis->EntityResponse
  "Embedded CodedInputStream to EntityResponse"
  [is]
  (serdes.core/cis->embedded cis->EntityResponse is))

(defn new-EntityResponse
  "Creates a new instance from a map, similar to map->EntityResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::EntityResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::EntityResponse-spec init))))]}
  (-> (merge EntityResponse-defaults init)
      (map->EntityResponse-record)))

(defn pb->EntityResponse
  "Protobuf to EntityResponse"
  [input]
  (cis->EntityResponse (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record EntityResponse-meta {:type "com.grpc.xtdb.EntityResponse" :decoder pb->EntityResponse})

;-----------------------------------------------------------------------------
; EntityHistoryRequest
;-----------------------------------------------------------------------------
(defrecord EntityHistoryRequest-record [sort-order start-tx-id end-tx-id with-corrections start-tx-time start-valid-time end-tx-time with-docs eid end-valid-time]
  pb/Writer
  (serialize [this os]
    (write-SortOrder 2  {:optimize true} (:sort-order this) os)
    (serdes.core/write-embedded 7 (:start-tx-id this) os)
    (serdes.core/write-embedded 10 (:end-tx-id this) os)
    (serdes.core/write-Bool 3  {:optimize true} (:with-corrections this) os)
    (serdes.core/write-String 6  {:optimize true} (:start-tx-time this) os)
    (serdes.core/write-String 5  {:optimize true} (:start-valid-time this) os)
    (serdes.core/write-String 9  {:optimize true} (:end-tx-time this) os)
    (serdes.core/write-Bool 4  {:optimize true} (:with-docs this) os)
    (serdes.core/write-String 1  {:optimize true} (:eid this) os)
    (serdes.core/write-String 8  {:optimize true} (:end-valid-time this) os))
  pb/TypeReflection
  (gettype [this]
    "com.grpc.xtdb.EntityHistoryRequest"))

(s/def :com.grpc.xtdb.EntityHistoryRequest/sort-order (s/or :keyword keyword? :int int?))

(s/def :com.grpc.xtdb.EntityHistoryRequest/with-corrections boolean?)
(s/def :com.grpc.xtdb.EntityHistoryRequest/start-tx-time string?)
(s/def :com.grpc.xtdb.EntityHistoryRequest/start-valid-time string?)
(s/def :com.grpc.xtdb.EntityHistoryRequest/end-tx-time string?)
(s/def :com.grpc.xtdb.EntityHistoryRequest/with-docs boolean?)
(s/def :com.grpc.xtdb.EntityHistoryRequest/eid string?)
(s/def :com.grpc.xtdb.EntityHistoryRequest/end-valid-time string?)
(s/def ::EntityHistoryRequest-spec (s/keys :opt-un [:com.grpc.xtdb.EntityHistoryRequest/sort-order :com.grpc.xtdb.EntityHistoryRequest/with-corrections :com.grpc.xtdb.EntityHistoryRequest/start-tx-time :com.grpc.xtdb.EntityHistoryRequest/start-valid-time :com.grpc.xtdb.EntityHistoryRequest/end-tx-time :com.grpc.xtdb.EntityHistoryRequest/with-docs :com.grpc.xtdb.EntityHistoryRequest/eid :com.grpc.xtdb.EntityHistoryRequest/end-valid-time]))
(def EntityHistoryRequest-defaults {:sort-order SortOrder-default :with-corrections false :start-tx-time "" :start-valid-time "" :end-tx-time "" :with-docs false :eid "" :end-valid-time ""})

(defn cis->EntityHistoryRequest
  "CodedInputStream to EntityHistoryRequest"
  [is]
  (->> (tag-map EntityHistoryRequest-defaults
                (fn [tag index]
                  (case index
                    2 [:sort-order (cis->SortOrder is)]
                    7 [:start-tx-id (ecis->OptionalInt64 is)]
                    10 [:end-tx-id (ecis->OptionalInt64 is)]
                    3 [:with-corrections (serdes.core/cis->Bool is)]
                    6 [:start-tx-time (serdes.core/cis->String is)]
                    5 [:start-valid-time (serdes.core/cis->String is)]
                    9 [:end-tx-time (serdes.core/cis->String is)]
                    4 [:with-docs (serdes.core/cis->Bool is)]
                    1 [:eid (serdes.core/cis->String is)]
                    8 [:end-valid-time (serdes.core/cis->String is)]

                    [index (serdes.core/cis->undefined tag is)]))
                is)
       (map->EntityHistoryRequest-record)))

(defn ecis->EntityHistoryRequest
  "Embedded CodedInputStream to EntityHistoryRequest"
  [is]
  (serdes.core/cis->embedded cis->EntityHistoryRequest is))

(defn new-EntityHistoryRequest
  "Creates a new instance from a map, similar to map->EntityHistoryRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::EntityHistoryRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::EntityHistoryRequest-spec init))))]}
  (-> (merge EntityHistoryRequest-defaults init)
      (cond-> (some? (get init :start-tx-id)) (update :start-tx-id new-OptionalInt64))
      (cond-> (some? (get init :end-tx-id)) (update :end-tx-id new-OptionalInt64))
      (map->EntityHistoryRequest-record)))

(defn pb->EntityHistoryRequest
  "Protobuf to EntityHistoryRequest"
  [input]
  (cis->EntityHistoryRequest (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record EntityHistoryRequest-meta {:type "com.grpc.xtdb.EntityHistoryRequest" :decoder pb->EntityHistoryRequest})

;-----------------------------------------------------------------------------
; OptionalBool
;-----------------------------------------------------------------------------
(defrecord OptionalBool-record [option]
  pb/Writer
  (serialize [this os]
    (write-OptionalBool-option  (:option this) os))
  pb/TypeReflection
  (gettype [this]
    "com.grpc.xtdb.OptionalBool"))

(s/def ::OptionalBool-spec (s/keys :opt-un []))
(def OptionalBool-defaults {})

(defn cis->OptionalBool
  "CodedInputStream to OptionalBool"
  [is]
  (->> (tag-map OptionalBool-defaults
                (fn [tag index]
                  (case index
                    1 [:option {:some (serdes.core/cis->Bool is)}]
                    2 [:option {:none (ecis->None is)}]

                    [index (serdes.core/cis->undefined tag is)]))
                is)
       (map->OptionalBool-record)))

(defn ecis->OptionalBool
  "Embedded CodedInputStream to OptionalBool"
  [is]
  (serdes.core/cis->embedded cis->OptionalBool is))

(defn new-OptionalBool
  "Creates a new instance from a map, similar to map->OptionalBool except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::OptionalBool-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::OptionalBool-spec init))))]}
  (-> (merge OptionalBool-defaults init)
      (convert-OptionalBool-option)
      (map->OptionalBool-record)))

(defn pb->OptionalBool
  "Protobuf to OptionalBool"
  [input]
  (cis->OptionalBool (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record OptionalBool-meta {:type "com.grpc.xtdb.OptionalBool" :decoder pb->OptionalBool})

;-----------------------------------------------------------------------------
; EntityTxRequest
;-----------------------------------------------------------------------------
(defrecord EntityTxRequest-record [eid]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:eid this) os))
  pb/TypeReflection
  (gettype [this]
    "com.grpc.xtdb.EntityTxRequest"))

(s/def :com.grpc.xtdb.EntityTxRequest/eid string?)
(s/def ::EntityTxRequest-spec (s/keys :opt-un [:com.grpc.xtdb.EntityTxRequest/eid]))
(def EntityTxRequest-defaults {:eid ""})

(defn cis->EntityTxRequest
  "CodedInputStream to EntityTxRequest"
  [is]
  (->> (tag-map EntityTxRequest-defaults
                (fn [tag index]
                  (case index
                    1 [:eid (serdes.core/cis->String is)]

                    [index (serdes.core/cis->undefined tag is)]))
                is)
       (map->EntityTxRequest-record)))

(defn ecis->EntityTxRequest
  "Embedded CodedInputStream to EntityTxRequest"
  [is]
  (serdes.core/cis->embedded cis->EntityTxRequest is))

(defn new-EntityTxRequest
  "Creates a new instance from a map, similar to map->EntityTxRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::EntityTxRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::EntityTxRequest-spec init))))]}
  (-> (merge EntityTxRequest-defaults init)
      (map->EntityTxRequest-record)))

(defn pb->EntityTxRequest
  "Protobuf to EntityTxRequest"
  [input]
  (cis->EntityTxRequest (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record EntityTxRequest-meta {:type "com.grpc.xtdb.EntityTxRequest" :decoder pb->EntityTxRequest})

;-----------------------------------------------------------------------------
; EntityTxResponse
;-----------------------------------------------------------------------------
(defrecord EntityTxResponse-record [xt-id content-hash valid-time tx-time tx-id]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:xt-id this) os)
    (serdes.core/write-String 2  {:optimize true} (:content-hash this) os)
    (serdes.core/write-String 3  {:optimize true} (:valid-time this) os)
    (serdes.core/write-String 4  {:optimize true} (:tx-time this) os)
    (serdes.core/write-Int32 5  {:optimize true} (:tx-id this) os))
  pb/TypeReflection
  (gettype [this]
    "com.grpc.xtdb.EntityTxResponse"))

(s/def :com.grpc.xtdb.EntityTxResponse/xt-id string?)
(s/def :com.grpc.xtdb.EntityTxResponse/content-hash string?)
(s/def :com.grpc.xtdb.EntityTxResponse/valid-time string?)
(s/def :com.grpc.xtdb.EntityTxResponse/tx-time string?)
(s/def :com.grpc.xtdb.EntityTxResponse/tx-id int?)
(s/def ::EntityTxResponse-spec (s/keys :opt-un [:com.grpc.xtdb.EntityTxResponse/xt-id :com.grpc.xtdb.EntityTxResponse/content-hash :com.grpc.xtdb.EntityTxResponse/valid-time :com.grpc.xtdb.EntityTxResponse/tx-time :com.grpc.xtdb.EntityTxResponse/tx-id]))
(def EntityTxResponse-defaults {:xt-id "" :content-hash "" :valid-time "" :tx-time "" :tx-id 0})

(defn cis->EntityTxResponse
  "CodedInputStream to EntityTxResponse"
  [is]
  (->> (tag-map EntityTxResponse-defaults
                (fn [tag index]
                  (case index
                    1 [:xt-id (serdes.core/cis->String is)]
                    2 [:content-hash (serdes.core/cis->String is)]
                    3 [:valid-time (serdes.core/cis->String is)]
                    4 [:tx-time (serdes.core/cis->String is)]
                    5 [:tx-id (serdes.core/cis->Int32 is)]

                    [index (serdes.core/cis->undefined tag is)]))
                is)
       (map->EntityTxResponse-record)))

(defn ecis->EntityTxResponse
  "Embedded CodedInputStream to EntityTxResponse"
  [is]
  (serdes.core/cis->embedded cis->EntityTxResponse is))

(defn new-EntityTxResponse
  "Creates a new instance from a map, similar to map->EntityTxResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::EntityTxResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::EntityTxResponse-spec init))))]}
  (-> (merge EntityTxResponse-defaults init)
      (map->EntityTxResponse-record)))

(defn pb->EntityTxResponse
  "Protobuf to EntityTxResponse"
  [input]
  (cis->EntityTxResponse (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record EntityTxResponse-meta {:type "com.grpc.xtdb.EntityTxResponse" :decoder pb->EntityTxResponse})

;-----------------------------------------------------------------------------
; Function
;-----------------------------------------------------------------------------
(defrecord Function-record [xt-id arguments]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:xt-id this) os)
    (serdes.complex/write-repeated serdes.core/write-embedded 2 (:arguments this) os))
  pb/TypeReflection
  (gettype [this]
    "com.grpc.xtdb.Function"))

(s/def :com.grpc.xtdb.Function/xt-id string?)

(s/def ::Function-spec (s/keys :opt-un [:com.grpc.xtdb.Function/xt-id]))
(def Function-defaults {:xt-id "" :arguments []})

(defn cis->Function
  "CodedInputStream to Function"
  [is]
  (->> (tag-map Function-defaults
                (fn [tag index]
                  (case index
                    1 [:xt-id (serdes.core/cis->String is)]
                    2 [:arguments (serdes.complex/cis->repeated com.google.protobuf/ecis->Value is)]

                    [index (serdes.core/cis->undefined tag is)]))
                is)
       (map->Function-record)))

(defn ecis->Function
  "Embedded CodedInputStream to Function"
  [is]
  (serdes.core/cis->embedded cis->Function is))

(defn new-Function
  "Creates a new instance from a map, similar to map->Function except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Function-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Function-spec init))))]}
  (-> (merge Function-defaults init)
      (cond-> (some? (get init :arguments)) (update :arguments #(map com.google.protobuf/new-Value %)))
      (map->Function-record)))

(defn pb->Function
  "Protobuf to Function"
  [input]
  (cis->Function (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Function-meta {:type "com.grpc.xtdb.Function" :decoder pb->Function})

;-----------------------------------------------------------------------------
; Transaction
;-----------------------------------------------------------------------------
(defrecord Transaction-record [transaction-type]
  pb/Writer
  (serialize [this os]
    (write-Transaction-transaction-type  (:transaction-type this) os))
  pb/TypeReflection
  (gettype [this]
    "com.grpc.xtdb.Transaction"))

(s/def ::Transaction-spec (s/keys :opt-un []))
(def Transaction-defaults {})

(defn cis->Transaction
  "CodedInputStream to Transaction"
  [is]
  (->> (tag-map Transaction-defaults
                (fn [tag index]
                  (case index
                    1 [:transaction-type {:put (ecis->Put is)}]
                    2 [:transaction-type {:delete (ecis->Delete is)}]
                    3 [:transaction-type {:match (ecis->Match is)}]
                    4 [:transaction-type {:evict (ecis->Evict is)}]
                    5 [:transaction-type {:function (ecis->Function is)}]
                    6 [:transaction-type {:put-function (ecis->PutFunction is)}]

                    [index (serdes.core/cis->undefined tag is)]))
                is)
       (map->Transaction-record)))

(defn ecis->Transaction
  "Embedded CodedInputStream to Transaction"
  [is]
  (serdes.core/cis->embedded cis->Transaction is))

(defn new-Transaction
  "Creates a new instance from a map, similar to map->Transaction except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Transaction-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Transaction-spec init))))]}
  (-> (merge Transaction-defaults init)
      (convert-Transaction-transaction-type)
      (map->Transaction-record)))

(defn pb->Transaction
  "Protobuf to Transaction"
  [input]
  (cis->Transaction (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Transaction-meta {:type "com.grpc.xtdb.Transaction" :decoder pb->Transaction})

;-----------------------------------------------------------------------------
; OptionalInt64
;-----------------------------------------------------------------------------
(defrecord OptionalInt64-record [option]
  pb/Writer
  (serialize [this os]
    (write-OptionalInt64-option  (:option this) os))
  pb/TypeReflection
  (gettype [this]
    "com.grpc.xtdb.OptionalInt64"))

(s/def ::OptionalInt64-spec (s/keys :opt-un []))
(def OptionalInt64-defaults {})

(defn cis->OptionalInt64
  "CodedInputStream to OptionalInt64"
  [is]
  (->> (tag-map OptionalInt64-defaults
                (fn [tag index]
                  (case index
                    1 [:option {:some (serdes.core/cis->Int64 is)}]
                    2 [:option {:none (ecis->None is)}]

                    [index (serdes.core/cis->undefined tag is)]))
                is)
       (map->OptionalInt64-record)))

(defn ecis->OptionalInt64
  "Embedded CodedInputStream to OptionalInt64"
  [is]
  (serdes.core/cis->embedded cis->OptionalInt64 is))

(defn new-OptionalInt64
  "Creates a new instance from a map, similar to map->OptionalInt64 except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::OptionalInt64-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::OptionalInt64-spec init))))]}
  (-> (merge OptionalInt64-defaults init)
      (convert-OptionalInt64-option)
      (map->OptionalInt64-record)))

(defn pb->OptionalInt64
  "Protobuf to OptionalInt64"
  [input]
  (cis->OptionalInt64 (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record OptionalInt64-meta {:type "com.grpc.xtdb.OptionalInt64" :decoder pb->OptionalInt64})

;-----------------------------------------------------------------------------
; Match
;-----------------------------------------------------------------------------
(defrecord Match-record [document-id document-match valid-time]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:document-id this) os)
    (serdes.core/write-embedded 3 (:document-match this) os)
    (serdes.core/write-String 4  {:optimize true} (:valid-time this) os))
  pb/TypeReflection
  (gettype [this]
    "com.grpc.xtdb.Match"))

(s/def :com.grpc.xtdb.Match/document-id string?)

(s/def :com.grpc.xtdb.Match/valid-time string?)
(s/def ::Match-spec (s/keys :opt-un [:com.grpc.xtdb.Match/document-id :com.grpc.xtdb.Match/valid-time]))
(def Match-defaults {:document-id "" :valid-time ""})

(defn cis->Match
  "CodedInputStream to Match"
  [is]
  (->> (tag-map Match-defaults
                (fn [tag index]
                  (case index
                    1 [:document-id (serdes.core/cis->String is)]
                    3 [:document-match (com.google.protobuf/ecis->Value is)]
                    4 [:valid-time (serdes.core/cis->String is)]

                    [index (serdes.core/cis->undefined tag is)]))
                is)
       (map->Match-record)))

(defn ecis->Match
  "Embedded CodedInputStream to Match"
  [is]
  (serdes.core/cis->embedded cis->Match is))

(defn new-Match
  "Creates a new instance from a map, similar to map->Match except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Match-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Match-spec init))))]}
  (-> (merge Match-defaults init)
      (cond-> (some? (get init :document-match)) (update :document-match com.google.protobuf/new-Value))
      (map->Match-record)))

(defn pb->Match
  "Protobuf to Match"
  [input]
  (cis->Match (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Match-meta {:type "com.grpc.xtdb.Match" :decoder pb->Match})

